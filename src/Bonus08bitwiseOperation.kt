// Bitwise Operation(비트 연산) //

// 정수형 변수를 10진법이 아닌 2진법으로 연산
// 실무에서는 계산 용도로 사용하는 경우가 거의 없음
// (2진법을 이용한 연산 최적화가 필요하면 -> 컴파일러의 기능 사용)
// 정수형의 값을 비트 단위로 나눔 -> 데이터를 좀 더 작은 단위로 담음 -> 경제성 높이는 용도

// 하지만 비트 연산을 사용하는 부하도 무시할 수 없으므로
// 주로 플래그 값(여러개의 상태값을 0과 1로 담는 방법)을 처리하거나
// 예) 32비트 -> 숫자가 아닌, 32개의 값을 담는 용도(T/F, on/off, 유료회원/무료회원 등)
// 네트워크 등에서 프로토콜의 데이터 양을 줄이기 위해 자주 사용

// 01100011010101101111001010010101
// 상위 비트 <-------------> 하위 비트
// 맨 왼쪽의 비트는 '최상위 비트'라고 함

// 코틀린은 모든 정수형이 부호를 포함 -> 비트로 나타낼 때도 부호를 표시하기 위해
// 최상위 비트는 부호 비트로 사용 -> 0이면 양수(+), 1이면 음수(-)라고 생각하면 됨
// 예) 00010101 -> 최상위 비트가 0 -> 사실상 +0010101
// 예) 10010101 -> 최상위 비트가 1 -> 사실상 -0010101
// 아무튼 최상위 비트는 부호로 쓰기 때문에 데이터를 담지 않는 편이 좋음

fun main () {

    // Bitwise Operators(비트 연산자) //

    // 코틀린의 비트 연산자는 자바와 다르게 문자열로 이루어 진 게 특징임
    // (자바의 경우 &, |, ^, ~ 등을 사용)

    // and -> 비트가 둘 다 1인 자리만 1로 반환 -> 비트를 확인하거나 clear하는 데 사용
    // or -> 비트가 둘 중 하나라도 1인 자리는 1로 반환 -> 비트를 set(값을 1로 설정)하고 싶을 때 사용
    // xor -> 비트가 같은 자리는 0, 다른 자리는 1로 반환 -> 비트들이 동일한지 확인하는 데 사용
    // inv() -> 비트를 모두 반전시킴 -> 0은 1로, 1은 0으로

    // shl(shift left) -> 부호 비트를 제외한 모든 비트를 좌측으로 원하는 만큼 밀어냄
    // shr(shift right) -> 부호 비트를 제외한 모든 비트를 우측으로 원하는 만큼 밀어냄
    // ushr(unsigned shift right) -> 부호 비트를 포함한 모든 비트를 우측으로 원하는 만큼 밀어냄
    // 얘네는 셋을 묶어서 Bitwise Shift Operators(비트 시프트 연산자)라고 부르기도 함

    // 지정되지 않은 상위 비트들은 0으로 채워짐
    var bitData: Int = 0b10000 // 10000(2)

    bitData = bitData or (1 shl 2)
    // 10000(2) or 10100(2) -> 10100(2)

    println(bitData.toString(2))
//    10100

    var result = bitData and (1 shl 4)
    // 10100(2) and 10000(2) -> 10000(2)

    println(result.toString(2))
//    10000

    println(result shr 4)
    // 00001(2)
//    1

    bitData = bitData and((1 shl 4).inv())
    // 10100(2) and 10000(2).inv -> 10100(2) and 01111(2) -> 00100(2)

    println(bitData.toString(2))
//    100

    println((bitData xor(0b10100)).toString(2))
    // 00100(2) xor 10100(2) -> 10000(2)
//    10000

}